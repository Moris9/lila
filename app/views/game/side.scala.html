@(pov: Pov, tour: Option[lila.tournament.Tournament], withTourStanding: Boolean, userTv: Option[User] = None)(implicit ctx: Context)

@import pov._
@import lila.tournament.arena

<div class="side">
  <div class="side_box padded">
    <div class="game_infos" data-icon="@game.perfType match {
      case _ if game.fromPosition => {*}
      case _ if game.hasAi => {:}
      case _ if game.imported => {/}
      case Some(p) => {@p.iconChar}
      case _ => {8}
      }">

      <div class="header">
        <span class="setup">
          @game.clock.fold("∞")(_.show) • @game.perfType.map {
          case lila.rating.PerfType.KingOfTheHill => {@chess.Variant.KingOfTheHill.shortName}
          case pt => {@pt.name}
          } • @game.rated.fold(trans.rated(), trans.casual())
        </span>
        @game.pgnImport.flatMap(_.date).getOrElse(
        game.isBeingPlayed.fold(trans.playingRightNow(), momentFormat(game.createdAt))
        )
      </div>
      @game.pgnImport.flatMap(_.date).map { date =>
      Imported
      @game.pgnImport.flatMap(_.user).map { user =>
      by
      @userIdLink(user.some, None, false)
      <br />
      }
      }
    </div>
    <div class="players">
      @List(game.whitePlayer, game.blackPlayer).map { p =>
      <div class="player color-icon is @{p.color.name}">
        @playerLink(p, withOnline = false, withDiff = true)
      </div>
      }

    </div>
    @if(game.finishedOrAborted) {
    <div class="status">
      @gameEndStatus(game)
      @game.winner.map { winner =>
      • @winner.color.fold(trans.whiteIsVictorious(), trans.blackIsVictorious())
      }
    </div>
    }
    @if(game.variant.threeCheck) {
    <div class="check_count" data-icon="@lila.rating.PerfType("threeCheck").map(_.iconChar)">
      Checks given:
      @* Note that they are stored the other way round, as checks received *@
      <span class="player color white">@game.checkCount.black</span>
      <span class="player color black">@game.checkCount.white</span>
    </div>
    }
  </div>

  @userTv.map { u =>
  <div class="side_box">
    <h2 class="top user_tv" data-user-tv="@u.id" data-icon="1">&nbsp;@u.titleUsername</h2>
  </div>
  }

  @tour match {
  case Some(t: lila.tournament.StartedOrFinished) => {
  <div class="game_tournament side_box no_padding scroll-shadow-soft">
    <p class="top" data-icon="g"> @t.fullName</p>
    @t match {
    case t: lila.tournament.Started => {
    <div class="clock" data-time="@t.remainingSeconds">
      <div class="time" data-icon="p">@t.clockStatus</div>
    </div>
    }
    case _ => {
    }
    }
    @if(withTourStanding) {
    <table class="slist standing">
      <tbody>
        @t.rankedPlayers.map {
        case (rank, player) => {
        @defining((
        t scoreSheet player,
        // TODO FIXME that's a little ugly I must say.
        t.system.scoringSystem match {
        case ss @ arena.ScoringSystem => ss.scoreSheet(t, player.id).onFire
        case _                        => false
        })) {
        case (scoreSheet, onFire) => {
        <tr @if(ctx.userId.exists(player.id==)) { class="me" }>
          <td class="name">
            @if(player.withdraw) {
            <span data-icon="b" title="@trans.withdraw()"></span>
            } else {
            @if(t.isFinished && rank == 1) {
            <span data-icon="g" title="@trans.winner()"></span>
            } else {
            <span class="rank">@rank</span>
            }
            }
            @userInfosLink(player.id, none, withOnline = false)
          </td>
          <td class="total">
            <strong@if(onFire) { class="is-gold" data-icon="Q" }>@scoreSheet.total</strong>
          </td>
        </tr>
        <tr><td class="around-bar" colspan="3"><div class="bar" data-value="@scoreSheet.total"></div></td></tr>
        }
        }
        }
        }
      </tbody>
    </table>
    }
  </div>
  }
  case _ => {
  }
  }
</div>
